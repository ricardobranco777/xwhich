#!/usr/bin/env python3

"""
xwhich
"""

import argparse
import fnmatch
import os
import re
import sys
from collections import OrderedDict
from enum import Enum
from pathlib import Path
from typing import Iterator

VERSION = "1.1"

Pattern = Enum("Pattern", ["Shell", "Regex"])


def parse_args() -> argparse.Namespace:
    """
    Parse command line options
    """
    argparser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]))
    argparser.add_argument(
        "-a",
        "--all",
        action="store_true",
        help="show all occurrences instead of the first",
    )
    argparser.add_argument(
        "-i", "--insensitive", action="store_true", help="case insensitive search"
    )
    argparser.add_argument(
        "-P", "--paths", default=os.getenv("PATH"), help="restrict search to paths"
    )
    argparser.add_argument(
        "-s", "--shell", action="store_true", help="search shell pattern"
    )
    argparser.add_argument(
        "-x", "--regex", action="store_true", help="search regular expression"
    )
    argparser.add_argument("--version", action="version", version=f"%(prog)s {VERSION}")
    argparser.add_argument("command")
    return argparser.parse_args()


def xwhich(
    command: str,
    pattern: Pattern,
    ignore_case: bool = False,
    check_paths: str = os.getenv("PATH", default="."),
) -> Iterator[Path]:
    """
    Returns a generator with locations of command in PATH
    """
    # Use set to skip symlinked directories in PATH
    paths = OrderedDict.fromkeys(
        Path(d).resolve() for d in check_paths.split(os.pathsep) if Path(d).is_dir()
    )
    regex = None
    if pattern is Pattern.Shell:
        regex = fnmatch.translate(command)
    elif pattern is Pattern.Regex:
        regex = command
    if regex:
        flags = re.IGNORECASE if ignore_case else 0

    for path in paths:
        if regex or ignore_case:
            for file in path.iterdir():
                if regex:
                    if (
                        re.match(regex, file.name, flags)
                        and path.joinpath(file).is_file()
                    ):
                        yield path / file
                else:  # ignore_case
                    if file.name.lower() == command.lower():
                        yield path / file
        elif path.joinpath(command).is_file():
            yield path / command


def main():
    """
    Main function
    """
    opts = parse_args()
    if opts.regex and opts.shell:
        sys.exit("ERROR: The -s & -x options are mutually exclusive")
    pattern = None
    if opts.regex:
        pattern = Pattern.Regex
    elif opts.shell:
        pattern = Pattern.Shell
    for path in xwhich(
        opts.command,
        pattern=pattern,
        ignore_case=opts.insensitive,
        check_paths=opts.paths,
    ):
        print(os.fspath(path))
        if not opts.all:
            sys.exit(0)


if __name__ == "__main__":
    try:
        main()
    except InterruptedError:
        sys.exit(1)
